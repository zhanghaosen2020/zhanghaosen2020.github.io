#define _CRT_SECURE_NO_WARNINGS

#include<stdio.h>

//指针笔试题目相关


//int main()
//{
//	int a[5] = { 1, 2, 3, 4, 5 };
//	int* ptr = (int*)(&a + 1);
//	printf("%d,%d", *(a + 1), *(ptr - 1));
//	return 0;
//}


//由于还没学习结构体，这里告知结构体的大小是20个字节
//struct Test
//{
//	int Num;
//	char* pcName;
//	short sDate;
//	char cha[2];
//	short sBa[4];
//}*p = (struct Test*)0x100000;//结构体指针，p之后有能力指向这样一个结构体
////假设p 的值为0x100000。 如下表表达式的值分别为多少？
////已知，结构体Test类型的变量大小是20个字节
//int main()
//{
//	//关键就是学会指针+1和整形+1(这儿别忘)
//	printf("%p\n", p + 0x1);//一个结构体指针+1，跳过一个结构体
//	//0x100000+20 --> 0x100014
//	printf("%p\n", (unsigned long)p + 0x1);//整形变量+1，就是+1
//	//1048576+1=1048577-->0x100001
//	printf("%p\n", (unsigned int*)p + 0x1);//一个整形指针+1，跳过一个整形
//	//0x100004
//	//这里关键是看指针类型，指针类型占用几个字节，就跳过几个字节
//	return 0;
//}


//int main()
//{
//	//第一个指向数组的最后一位的后面，-1就是最后一位
//	//第二个是把首元素地址转换为整形再加1，就是首元素地址跳过一个字节，再转换为整形
//	//意思就是在元素1和的存储中往后偏移了一个字节再访问四个字节
//	int a[4] = { 1, 2, 3, 4 };
//	int* ptr1 = (int*)(&a + 1);
//	int* ptr2 = (int*)((int)a + 1);//   4
//	printf("%x,%x", ptr1[-1], *ptr2);// 2000000
//	return 0;
//}


//#include <stdio.h>
//int main()
//{			  //={{0,1},{2,3},{4,5}};
//	int a[3][2] = { (0, 1), (2, 3), (4, 5) };//这里就是个大坑,这其实是一个逗号表达式，和最后一个逗号有关
//	int*p;//野指针警告
//	p = a[0];//二维数组中，a[0]是第一行的数组名，表示首元素的地址，即a[0][0]的地址&a[0][0]
//	printf("%d", p[0]);//1
//	return 0;
//}

//int main()
//{
//	int a[5][5];
//	int(*p)[4];
//	p = a;
//	printf("%p,%d\n", &p[4][2] - &a[4][2], &p[4][2] - &a[4][2]);
//	return 0;
//}

//int main()
//{
//	int arr[4] = { 1,2,3,4 };
//	int aa[2][5] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
//	int* ptr1 = (int*)(&aa + 1);//&aa取出的是整个数组的地址，再+1就跳过整个数组了
//	int* ptr2 = (int*)(*(aa + 1));//aa+1就是跳过一行
//	//*(aa+1)==aa[1]表示第二行一行的地址(值为第二行首元素的地址)，类型是int[5],
//	//强制转换为了int*类型,*(ptr2-1)就是上边的指针指向的位置-1，在接应用也就是5
//
//	printf("%d,%d", *(ptr1 - 1), *(ptr2 - 1));
//	//ptr1-1取出的是最后一个元素的地址，ptr2-1取出的是第一行最后一个元素
//	//10  5
//	return 0;
//}

//笔试题八
//#include <stdio.h>
//int main()
//{
//	char* a[] = { "work","at","alibaba" };
//	char** pa = a;
//
//	pa++;
//	printf("%s\n", *pa);//
//	return 0;
//}

//int p; //这是一个普通的整型变量
//int* p; //首先从P 处开始,先与*结合,所以说明P 是一个指针,然后再与int 结合,
//		//说明指针所指向的内容的类型为int 型.所以P是一个返回整型数据的指针
//int p[3]; //首先从P 处开始,先与[]结合,说明P 是一个数组,然后与int 结合,
//		 //说明数组里的元素是整型的,所以P 是一个由整型数据组成的数组
//int* p[3]; //首先从P 处开始,先与[]结合,因为其优先级比*高,所以P 是一个数组,
//			//然后再与*结合,说明数组里的元素是指针类型,然后再与int 结合,
//			// 说明指针所指向的内容的类型是整型的,所以P 是一个由返回整型数据的指针所组成的数组
//int(*p)[3]; //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与"()"这步可以忽略,
////			只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,
//			// 说明数组里的元素是整型的.所以P 是一个指向由整型数据组成的数组的指针
//int** p; //首先从P 开始,先与*结合,说是P 是一个指针,然后再与*结合,
//		//说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.
//		// 由于二级指针以及更高级的指针极少用在复杂的类型中,所以后面更复杂的类型我们就不考虑多级指针了,
//		// 最多只考虑一级指针.
//int p(int); //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,
//			//然后再与外面的int 结合,说明函数的返回值是一个整型数据
//Int(*p)(int); //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,
//			//然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,
//			// 说明函数的返回类型是整型,所以P 是一个指向有一个整型参数且返回类型为整型的函数的指针
//int* (*p(int))[3]; //可以先跳过,不看这个类型,过于复杂从P 开始,先与()结合,说明P 是一个函数,
//	//然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的*结合,
//	// 说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,
//	// //说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,
//	// 然后再与int 结合,说明指针指向的内容是整型数据.
//	// 所以P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.


//int main()
//{
//	char* c[] = { "ENTER","NEW","POINT","FIRST" };
//	char** cp[] = { c + 3,c + 2,c + 1,c };
//	char*** cpp = cp;
//	printf("%s\n", **++cpp);
//	printf("%s\n", *-- * ++cpp + 3);//优先级：后置++（--）>前置++,-- > *(解引用) >+,-,*,/
//	printf("%s\n", *cpp[-2] + 3);
//	printf("%s\n", cpp[-1][-1] + 1);
//	return 0;
//}

