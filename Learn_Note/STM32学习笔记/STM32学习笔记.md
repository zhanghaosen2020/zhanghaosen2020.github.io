# STM32学习笔记

## 1.GPIO外设相关,2025/4/3

### 1.1用寄存器方式点亮LED灯

步骤:(以GPIOF--->Pin9为例)

```c
    //下面来尝试点亮  LED0 -- PF9 所控制
    //1.时钟配置,RCC寄存器对应的GPIOF时钟使能
    RCC->AHB1ENR |= 1<<5;
    // 2. 配置 Pin9 为输出模式
    GPIOF->MODER &= ~(3 << 18);     // 清除模式,2*9=18
    GPIOF->MODER |= 1 << 18;        // 通用输出模式（01）
    // 3. 配置输出速度为高速
    GPIOF->OSPEEDR &= ~(3 << 18);	//2*9=18
    GPIOF->OSPEEDR |= 2 << 18;      // 高速（10）
    // 4. 启用上拉电阻
    GPIOF->PUPDR &= ~(3 << 18);
    GPIOF->PUPDR |= 1 << 18;        // 上拉（01）
    // 5. 配置为推挽输出
    GPIOF->OTYPER &= ~(1 << 9);     // 清除类型（默认为推挽）
	while(1)//实现的是让LED闪烁的效果
	{
    // 6. 点亮 LED（假设低电平点亮）       
	GPIOF->BSRR = 1 << (9 + 16);     // BSRR高16位：Pin9置低 
    delay_ms(500);
    // 7. 熄灭 LED
    GPIOF->BSRR = 1 << 9;            // BSRR低16位：Pin9置高
    delay_ms(500);
//    GPIOF->ODR |= 1<<9; //熄灭
//    GPIOF->ODR &= ~(1<<9);//点亮,将控制语句换为这两句也是可以的,但是更加推荐上面的方式(原因如下)
	}
```

注意:

1. 在嵌入式开发中，**原子操作**（Atomic Operation）指的是一个不可被中断的完整操作——要么全部执行成功，要么完全不执行，中间不会被其他代码（如中断、多线程）打断。而 **"无需读-改-写"** 指的是不需要先读取寄存器当前值、修改特定位、再写回寄存器的传统流程，而是**直接通过寄存器设计实现单步原子操作**。

2. ##### 为什么需要原子操作？

   当多个代码（如主循环和中断）同时操作同一个寄存器时，传统的 **读-改-写**（Read-Modify-Write）流程可能引发 **竞态条件**（Race Condition）。例如：

   ```c
   // 假设在中断中操作GPIO的某个位：
   void Interrupt_Handler() {
       GPIOA->ODR |= 1 << 5; // 读-改-写：读取ODR，设置Bit5，再写回
   }
   // 主循环中同时操作另一个位：
   void main() {
       GPIOA->ODR |= 1 << 6; // 读-改-写
   }
   ```

   如果中断在主循环的 **读** 和 **写** 之间触发，主循环的修改会被中断的写入覆盖，导致数据不一致。

   3.STM32的解决方案：BSRR寄存器，STM32的GPIO模块提供了一个专用寄存器 **BSRR**（Bit Set/Reset Register），它的设计允许直接通过单次写操作设置或清除某个GPIO位，无需读-改-写，天然支持原子操作。

关键总结：

| 特性         | 读-改-写（ODR）      | BSRR原子操作         |
| :----------- | :------------------- | :------------------- |
| **操作步骤** | 读→改→写（3步）      | 直接写（1步）        |
| **竞态风险** | 高（可能被中断打断） | 无（单步原子操作）   |
| **代码效率** | 低（需要多次操作）   | 高（单指令完成）     |
| **适用场景** | 需要同时修改多个位   | 单一位或独立位的操作 |

### ![image-20250403095816024](STM32学习笔记.assets/image-20250403095816024.png)1.2补充F407系列芯片手册与stm32f407xx.h头文件的关系

![image-20250403085350365](STM32学习笔记.assets/image-20250403085350365.png)

![image-20250403085522758](STM32学习笔记.assets/image-20250403085522758.png)

1.上两张图可以看出是一一对应的关系，即头文件中定义了一个结构体RCC_TypeDef，里边的成员变量是按照内存器表排序的

![image-20250403090018808](STM32学习笔记.assets/image-20250403090018808.png)

![image-20250403090112204](STM32学习笔记.assets/image-20250403090112204.png)

![image-20250403090138331](STM32学习笔记.assets/image-20250403090138331-1743644080778-6.png)

![image-20250403090156948](STM32学习笔记.assets/image-20250403090156948.png)

2.RCC是一个大的单元，他被宏定义成了一个（RCC_TypeDef*）RCC_BASE 的地址，一步步深挖，可以发现地址相加在一起，刚好是外设基地址+AHB1外设基地址+RCC的基地址，定位到RCC这个打的模块上



### 1.3尝试解读一下正点原子所给的一些封装好的代码

这是封装好的函数，我们看看他都干了些啥？

![image-20250403091137207](STM32学习笔记.assets/image-20250403091137207.png)

1. 使能时钟![image-20250403091306962](STM32学习笔记.assets/image-20250403091306962.png)
2. GPIO复用功能设置![image-20250403091449288](STM32学习笔记.assets/image-20250403091449288.png)

该函数逻辑

1. **循环遍历所有引脚（0到15）**

   ```c
   for (pinpos = 0; pinpos < 16; pinpos++)
   ```

   - GPIO端口通常有16个引脚（从0到15），通过循环逐个检查每个引脚是否需要配置。

2. **检查当前引脚是否需要配置**

   ```c
   pos = 1 << pinpos;      /* 生成当前引脚的掩码 */
   curpin = pinx & pos;    /* 检查引脚是否在pinx中 */
   if (curpin == pos)      /* 如果需要配置 */
   ```

   - `pos`是一个掩码，用于检查`pinx`中是否包含当前引脚（例如，`pinx`为`0x0001`表示第0引脚，`0x0002`表示第1引脚）。
   - 如果`curpin`等于`pos`，说明当前引脚需要配置。

3. **配置GPIO模式**

   ```c
   p_gpiox->MODER &= ~(3 << (pinpos * 2)); /* 清除原来的设置 */
   p_gpiox->MODER |= mode << (pinpos * 2); /* 设置新的模式 */
   ```

   - 每个GPIO引脚的模式由2位表示（`MODER`寄存器的每2位对应一个引脚）。
   - `~(3 << (pinpos * 2))`：生成一个掩码，将对应引脚的2位清零。
   - `mode << (pinpos * 2)`：将新的模式值左移到对应位置，并写入`MODER`寄存器。

4. **配置输出速度和输出类型（如果模式是输出或复用功能模式）**

   ```c
   if ((mode == 0X01) || (mode == 0X02))   /* 如果是输出模式或复用功能模式 */
   {
       p_gpiox->OSPEEDR &= ~(3 << (pinpos * 2));       /* 清除原来的设置 */
       p_gpiox->OSPEEDR |= (ospeed << (pinpos * 2));   /* 设置新的速度值 */
       p_gpiox->OTYPER &= ~(1 << pinpos);             /* 清除原来的设置 */
       p_gpiox->OTYPER |= otype << pinpos;             /* 设置新的输出模式 */
   }
   ```

   - **`OSPEEDR`寄存器**：用于设置GPIO引脚的输出速度。
   - **`OTYPER`寄存器**：用于设置GPIO引脚的输出类型（推挽或开漏）。
   - 只有当引脚模式为输出模式（`0x01`）或复用功能模式（`0x02`）时，才需要配置输出速度和输出类型。

5. **配置上下拉电阻**

   ```c
   p_gpiox->PUPDR &= ~(3 << (pinpos * 2)); /* 先清除原来的设置 */
   p_gpiox->PUPDR |= pupd << (pinpos * 2); /* 设置新的上下拉 */
   ```

   - **`PUPDR`寄存器**：用于配置GPIO引脚的上下拉电阻。
   - 每个引脚的上下拉电阻由2位表示，通过类似的操作清除旧值并设置新值。

总结一下，这个函数就是把这块开发板对应的端口做了封装，对于GPIOx(A,B...)进行了封装,使得通过上边的一个函数对所有的GPIO进行初始化配置,其代码本质上还是在控制各类寄存器(将1.1的部分又封装了一层,并且使其具有通用性)

3.GPIO引脚输出电平的控制

![image-20250403092517934](STM32学习笔记.assets/image-20250403092517934.png)

**可以清除的发现也是通过控制BSRR来控制引脚的高低电平的**

### 1.4GPIO基本结构分析

![image-20250403165303491](STM32学习笔记.assets/image-20250403165303491.png)

**① 保护二极管**:

保护二极管共有两个，**用于保护引脚外部过高或过低的电压输入。当引脚输入电压高于VDD 时**（意味着这个保护电路往往是在输入模式的情况下才会生效），上面的二极管导通，当引脚输入电压低于 VSS 时，下面的二极管导通，从而使输入芯片内部的电压处于比较稳定的值。虽然有二极管的保护，但这样的保护却很有限，大电压大电流的接入很容易烧坏芯片。所以在实际的设计中我们要考虑设计引脚的保护电路。

**② 上拉、下拉电阻**

它们阻值大概在 30~50K 欧之间，可以通过上、下两个对应的开关控制，这两个开关由寄存器控制。当引脚外部的器件没有干扰引脚的电压时，即没有外部的上、下拉电压，引脚的电平由引脚内部上、下拉决定，开启内部上拉电阻工作，引脚电平为高，开启内部下拉电阻工作，则引脚电平为低。同样，如果内部上、下拉电阻都不开启，这种情况就是我们所说的浮空模式。浮空模式下，引脚的电平是不可确定的。引脚的电平可以由外部的上、下拉电平决定。

注意:感谢铁头山羊的GPIO讲解，让我知道了，当io输入断开时，单片机内部犹如一个无限大阻值的电阻，io引脚就像个条线，会接受电磁信号，这对32的输入是干扰源的存在因此需要适时的开启上拉下拉电阻，保证引脚处于一个高或者低对的电平，杜绝电磁信号的干扰，并且当单片机复位之后所有gpio都会被设置为符空状态，达到高阻抗状态(起到安全，节能的作用)

**③施密特触发器**,存在于输入部分

![image-20250403165955939](STM32学习笔记.assets/image-20250403165955939.png)

**④** **P-MOS** **管和** **N-MOS** **管**

这个结构控制 GPIO 的开漏输出和推挽输出两种模式。开漏输出：输出端相当于三极管的集电极，要得到高电平状态需要上拉电阻才行。推挽输出：这两只对称的 MOS 管每次只有一只导通，所以导通损耗小、效率高。输出既可以向负载灌电流，也可以从负载拉电流。推拉式输出既能提高电路的负载能力，又能提高开关速度。

#### 1.4.1推挽输出

![image-20250403171625164](STM32学习笔记.assets/image-20250403171625164.png)

![image-20250403171555068](STM32学习笔记.assets/image-20250403171555068.png)

通过	控制置位/复位寄存器间接控制输出数据寄存器	或	直接控制输出数据寄存器来控制P-Mos和N-Mos的通断进而实现

"推电流,挽电流"的操作,直接将引脚置为高低电平，此时要注意输入数据部分是被打开的，意思是，我们可以读取当前IO口的状态。

**特性**

- **驱动能力强**：能直接输出高/低电平，无需外部上拉电阻。
- **高低电平切换速度快**：适合高速信号（如SPI、PWM）。
- **无外部元件依赖**：独立驱动负载（如LED、继电器）。

**典型应用**

- 需要强驱动能力的场景：LED控制、数字信号传输（SPI、USART）。
- 单设备独占总线的情况

#### 1.4.2开漏输出

![image-20250403172937535](STM32学习笔记.assets/image-20250403172937535.png)

**开漏模式下，P-MOS 管是一直截止的，**所以 P-MOS 管的栅极一直接 VSS。

如果输出数据寄存器设置为 0 时，经过“输出控制”的逻辑非操作后，输出逻辑 1 到 N-MOS 管的栅极，这时 N-MOS 管就会导通，使得 I/O 引脚接到 VSS，即输出低电平。

如果输出数据寄存器设置为 1 时，经过“输出控制器”的逻辑非操作后，输出逻辑 0 到 N-MOS 管的栅极，这时 N-MOS 管就会截止。

**因为 P-MOS 管是一直截止的，使得 I/O 引脚呈现高阻态，即不输出低电平，也不输出高电平。**因此要 I/O 引脚输出高电平就必须接上拉电阻。这时可以接内部上拉电阻，或者接一个外部上拉电阻。由于内部上拉电阻的阻值较大，所以只是“弱上拉”。需要大电流驱动，请接外部的上拉电阻。此外，**上拉电阻具有线与特性，即如果有很多开漏模式的引脚连在一起的时候，只有当所有引脚都输出高阻态，电平才为 1，只要有其中一个为低电平时，就等于接地，使得整条线路都为低电平 0。我们的 IIC 通信（IIC_SDA）就用到这个原理。**另外在开漏输出模式下，施密特触发器是打开的，所以 IO 口引脚的电平状态会被采集到输入数据寄存器中，如果对输入数据寄存器进行读访问可以得到 IO 口的状态。**也就是说开漏输出模式下，我们可以对 IO 口进行读数据。**

**特性**

- **电平灵活性**：通过外部上拉电阻可适配不同电压（如3.3V或5V系统）。
- **总线共享**：支持“线与”逻辑，多个设备可共享同一总线（如I2C）。
- **驱动能力弱**：高电平依赖外部上拉电阻，上升沿可能较慢。

**典型应用**

- 多设备总线通信：I2C、SMBUS（避免总线冲突）。
- 电平转换：连接不同电压的器件。
- 需要“线与”逻辑的场景（如多中断信号共享）。

**两种输出方式的关键对比**

| **特性**         | **推挽输出**         | **开漏输出**              |
| :--------------- | :------------------- | :------------------------ |
| **电路结构**     | P-MOS + N-MOS        | 仅N-MOS，P-MOS关闭        |
| **高电平驱动**   | 直接由VDD提供        | 依赖外部上拉电阻          |
| **低电平驱动**   | 直接由GND提供        | 直接由GND提供             |
| **电平切换速度** | 快（双MOS驱动）      | 慢（依赖上拉电阻）        |
| **总线冲突风险** | 高（可能短路）       | 低（支持线与逻辑）        |
| **典型应用**     | LED、SPI、单设备通信 | I2C、电平转换、多设备总线 |

**应用示例**

- **I2C总线**：必须使用开漏模式，配合上拉电阻实现多设备通信。

- **5V传感器接口**：开漏模式+外部5V上拉，实现3.3V MCU与5V传感器电平兼容。

- **LED控制**：推挽模式直接驱动，无需额外电路

  

  #### 示例:（下边的示例都需要上拉电阻，来提供支持）

![image-20250404150715798](STM32学习笔记.assets/image-20250404150715798.png)

![image-20250404150913873](STM32学习笔记.assets/image-20250404150913873.png)

假设使用图一的推挽输出，就难以实现5v的MCU对3.3V芯片的控制，而使用开漏输出下边这个Mos管的开闭配合外部上拉电阻，就实现了控制。

![image-20250404151214792](STM32学习笔记.assets/image-20250404151214792.png)

当需要实现，**几个GPIO控制一个芯片这样的需求的时候，推挽就容易出现上边的情况（Mos烧毁）**

![image-20250404151403900](STM32学习笔记.assets/image-20250404151403900.png)

开漏输出的好处，便体现了出来

#### 1.4.3复用输出（2025/4/4）

![img](STM32学习笔记.assets/wps1.jpg)

（1）在开漏或推挽式配置中，输出缓冲器被打开。

（2）内置外设的信号驱动输出缓冲器（复用功能输出）。

（3）施密特触发输入被激活。

（4）弱上拉和下拉电阻被禁止。（因为输入时才需要上下拉电阻）

复用输出与通用输出的最大区别就在于，数据的来源，前者来自于其他的片上外设，后者来自于MUC内部，因而你可以看到	输出数据寄存器	是出于一个被断开的状态

#### 1.4.4输入模式

![img](STM32学习笔记.assets/wps2.jpg)

（1）2个保护二极管的作用是保护我们的芯片不会由于电压过高或过低而烧毁。

VDD是接电源（3.3V），VSS接地（0V）。如果IO引脚的输入电压高于VDD的值到一定程度，上方保护二极管导通，则引脚电压被拉低到VDD。如果IO引脚的输入电压（负电压）低于VSS到一定程度，则下方保护二极管导通，电压被拉高到VSS。

（2）2个开关控制引脚在没有输入的时候是上拉，下拉还是浮空。当上面的开关闭合的时候，输入被拉高到高电平。当下面的开关闭合的时候，输入被拉低到低电平。如果两个都不闭合，输入就是悬空状态。两个同时闭合，就是费电了，不会这么做的。

- 输入浮空（Input floating）
- 输入上拉（Input pull-up）
- 输入下拉（Input-pull-down）

![img](STM32学习笔记.assets/wps3.jpg) 

（3）施密特（图中翻译成肖特基触发器应该是翻译错误，英文版手册是TTL Schmitt trigger）触发器是包含正反馈的比较器电路。可以对信号进行波形整形。

![img](STM32学习笔记.assets/wps4.jpg) 

![img](STM32学习笔记.assets/wps5.jpg) 

（4）从施密特触发起出来的数据，进入到输入数据寄存器中，我们就可以从中读取数据了。

#### 1.4.5模拟输入

![image-20250404161012169](STM32学习笔记.assets/image-20250404161012169.png)

当配置为模拟输入时：

（1）输出部分被禁止。

（2）**禁止施密特触发输入**，实现了每个模拟I/O引脚上的零消耗。施密特触发输出值被强置为0。

（3）弱上拉和下拉电阻被禁止。

（4）读取输入数据寄存器时数值永远为0。